# -*- coding: utf-8 -*-
"""Homework-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FUplQ6sfYx8Vh_Qgk4mHNOGBKaQvi6na

Problem 1

First let's represent the maze as a graph. I'll use a dictionary with each tile being a node (key) and the values are the adjacent tiles. Each tile is represented as their coordinates on the board.
"""

maze = {
    (0,0): [(0,1)],
    (0,1): [(0,0), (0,2)],
    (0,2): [(0,1), (0,3)],
    (0,3): [(0,2), (0,4), (1,3)],
    (0,4): [(0,3)],
    (1,0): [(1,1), (2,0)],
    (1,1): [(1,0), (1,2)],
    (1,2): [(1,1), (1,3)],
    (1,3): [(0,3), (1,2), (1,4), 2,3],
    (1,4): [(1,3), (2,4)],
    (2,0): [(1,0), (3,0)],
    (2,1): [(3,1)],
    (2,2): [(3,2)],
    (2,3): [(1,3)],
    (2,4): [(1,4), (3,4)],
    (3,0): [(2,0), (3,1)],
    (3,1): [(3,0), (3,2), (2,1)],
    (3,2): [(3,1), (2,2), (4,2)],
    (3,3): [(4,3)],
    (3,4): [(2,4), (4,4)],
    (4,0): [(4,1)],
    (4,1): [(4,2)],
    (4,2): [(3,2), (4,1), (4,3)],
    (4,3): [(4,2), (4,4)],
    (4,4): [(4,3), (3,4)],
}

"""Let's use DFS to search a path to the goal."""

def find_path(maze, current_tile, visited, path, goal):
  visited.append(current_tile)
  path.append(current_tile)

  for adjacent_tile in maze[current_tile]:
    if adjacent_tile == goal:
      path.append(goal)
      print("Goal found at: ", path)
      return path, visited
    else:
      if adjacent_tile not in visited:
        print("Moving to next tile: ", adjacent_tile)
        path, visited = find_path(maze, adjacent_tile, visited, path, goal)
        if len(path) != 0 and goal in path:
          return path, visited
  print("Dead-end, move back!")
  path.pop()
  return path, visited

start = (0,0)
goal = (2,1)

visited = []
path = []

path, visited = find_path(maze, start, visited, path, goal)
print("Path to goal:", path)

-------------------------------------------------------------------------------------------------------------------------------------------------

Problem 2

import random
from random import choices
import math

# Let's first create a dictionary to represent the graph.

cities = {
    "a": {"b": 12, "c": 10, "g": 12},
    "b": {"a": 12, "c": 8, "d": 12},
    "c": {"a": 10, "b": 8, "d": 11, "e": 3, "g": 9},
    "d": {"b": 12, "c": 11, "e": 11, "f": 10},
    "e": {"c": 3, "d": 11, "f": 6, "g": 7},
    "f": {"d": 10, "e": 6, "g": 9},
    "g": {"a": 12, "c": 9, "e": 7, "f": 9}
}

# Fucntion to create random (legal) order of cities

populationSize = 100
numberOfGenerations = 1000

def createOrder(cities):
  currentCity = "a"
  visitedCities = ["a"]

  while True:
    newNeighbors = False
    for neighbor in cities[currentCity]:
      if neighbor[0] not in visitedCities:
        newNeighbors = True

    if newNeighbors == False:
      currentCity = "a"
      visitedCities = ["a"]
      continue

    city, distance = random.choice(list(cities[currentCity].items()))
    if city not in visitedCities:
      currentCity = city
      visitedCities.append(currentCity)

    else:
      continue

    if len(visitedCities) == 7:
      if currentCity in ["b", "c", "g"]:
        visitedCities.append("a")
        return visitedCities
      else:
        currentCity = "a"
        visitedCities = ["a"]

# Function to create n size population

def createPopulation(cities, n):
  population = []

  for i in range(n):
    population.append(createOrder(cities))

  return population

population = createPopulation(cities, populationSize)

# Function to calculate fitness of one order

def calculateDistance(cities, order):
  currentCity = order[0]
  distance = 0

  for i in range(7):
    distance += cities[order[i]][order[i+1]]

  return distance

totalDistance = 0
distances = []
for i in range(populationSize):
  distancePowered = pow(calculateDistance(cities, population[i]), 30)
  totalDistance += 1 / distancePowered
  distances.append(1 / distancePowered)

fitnesses = []
for i in range(populationSize):
  fitnesses.append(distances[i]/totalDistance)

def chooseParents(population, fitnesses):
  while True:
    parent1 = random.choices(population, fitnesses)[0]
    parent2 = random.choices(population, fitnesses)[0]
    return parent1, parent2


def mutate(cities, parent1, parent2):
  splitPoint1 = random.randint(3,5)
  splitPoint2 = random.randint(3,5)
  child = parent1[0:splitPoint1]
  child.extend(parent2[splitPoint1:])
  if isValidChild(cities, child):
    return [child]
  return []

def isValidChild(cities, child):
  for i in range(len(child) - 1):
    if child[i+1] not in cities[child[i]]:
      return False
  if len(child[1:-1]) != len(set(child[1:-1])):
    return False
  return True

for i in range(numberOfGenerations):
  sum = 0
  children = []
  while len(children) < populationSize:
    parent1, parent2 = chooseParents(population, fitnesses)
    child = mutate(cities, parent1, parent2)
    children.extend(child)
  lowest = math.inf
  for child in children:
    if calculateDistance(cities, child) < lowest:
      lowest = calculateDistance(cities, child)
  print("lowest this generation: ", lowest)
  population = children

-----------------------------------------------------------------------------------------------------------------------------------

# Problem 3
import random

# Initialize the Tic-Tac-Toe board
board = [' ' for _ in range(9)]

# Function to print the Tic-Tac-Toe board
def print_board(board):
    print(f"{board[0]} | {board[1]} | {board[2]}")
    print("-" * 9)
    print(f"{board[3]} | {board[4]} | {board[5]}")
    print("-" * 9)
    print(f"{board[6]} | {board[7]} | {board[8]}")

# Function to check if the board is full
def is_full(board):
    return ' ' not in board

# Function to check if a player has won
def check_win(board, player):
    win_combinations = [(0, 1, 2), (3, 4, 5), (6, 7, 8), (0, 3, 6), (1, 4, 7), (2, 5, 8), (0, 4, 8), (2, 4, 6)]
    for a, b, c in win_combinations:
        if board[a] == board[b] == board[c] == player:
            return True
    return False

# Function for the computer's move using the minimax algorithm
def computer_move(board):
    best_score = -float('inf')
    best_move = None
    for i in range(9):
        if board[i] == ' ':
            board[i] = 'O'  # Try the move
            score = minimax(board, 0, False)
            board[i] = ' '  # Undo the move
            if score > best_score:
                best_score = score
                best_move = i
    return best_move

# Minimax algorithm
def minimax(board, depth, is_maximizing):
    scores = {'O': 1, 'X': -1, 'Tie': 0}

    if check_win(board, 'O'):
        return scores['O']
    if check_win(board, 'X'):
        return scores['X']
    if is_full(board):
        return scores['Tie']

    if is_maximizing:
        best_score = -float('inf')
        for i in range(9):
            if board[i] == ' ':
                board[i] = 'O'
                score = minimax(board, depth + 1, False)
                board[i] = ' '
                best_score = max(score, best_score)
        return best_score
    else:
        best_score = float('inf')
        for i in range(9):
            if board[i] == ' ':
                board[i] = 'X'
                score = minimax(board, depth + 1, True)
                board[i] = ' '
                best_score = min(score, best_score)
        return best_score

# Main game loop
while True:
    print_board(board)

    # Player's move
    while True:
        player_move = int(input("Enter your move (1-9): ")) - 1
        if 0 <= player_move < 9 and board[player_move] == ' ':
            board[player_move] = 'X'
            break
        else:
            print("Invalid move. Try again.")

    # Check for a player win or tie
    if check_win(board, 'X'):
        print_board(board)
        print("Congratulations! You win!")
        break
    if is_full(board):
        print_board(board)
        print("It's a tie!")
        break

    # Computer's move
    computer_best_move = computer_move(board)
    board[computer_best_move] = 'O'

    # Check for a computer win or tie
    if check_win(board, 'O'):
        print_board(board)
        print("Sorry, you lose. The computer wins!")
        break
    if is_full(board):
        print_board(board)
        print("It's a tie!")
        break
